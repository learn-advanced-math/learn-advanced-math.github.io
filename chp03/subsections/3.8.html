<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="alternate icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiI+PGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTUiIGZpbGw9IiMzNDk4ZGIiIHN0cm9rZT0iIzJjM2U1MCIgc3Ryb2tlLXdpZHRoPSIyIi8+PGcgZmlsbD0id2hpdGUiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC13ZWlnaHQ9ImJvbGQiPjx0ZXh0IHg9IjE2IiB5PSIxMyIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIxMiI+ZDwvdGV4dD48bGluZSB4MT0iOCIgeTE9IjE2IiB4Mj0iMjQiIHkyPSIxNiIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIxLjUiLz48dGV4dCB4PSIxNiIgeT0iMjUiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZvbnQtc2l6ZT0iMTAiPmR4PC90ZXh0PjwvZz48L3N2Zz4=">
    <title>3.8 方程的近似解 - 高等数学复习</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']]
            },
            chtml: {
                fontURL: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            margin-bottom: 20px;
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .back-link:hover {
            color: #2980b9;
            transform: translateX(-5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        }
        
        .back-link::before {
            content: '←';
            margin-right: 8px;
            font-size: 1.2em;
        }
        
        header {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-weight: 300;
        }
        
        .subtitle {
            font-size: 1.1em;
            margin-top: 10px;
            opacity: 0.9;
        }
        
        .content-section {
            background: white;
            margin: 25px 0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .content-section:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .section-header {
            padding: 20px 30px;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }
        
        .section-header h2 {
            margin: 0;
            font-size: 1.6em;
            font-weight: 400;
        }
        
        .section-content {
            padding: 30px;
        }
        
        .definition {
            background: linear-gradient(135deg, #f4f0f8, #ece2f0);
            border-left: 5px solid #e74c3c;
            padding: 25px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
            box-shadow: 0 3px 15px rgba(231, 76, 60, 0.1);
        }
        
        .definition h4 {
            margin: 0 0 15px 0;
            color: #e74c3c;
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .theorem {
            background: linear-gradient(135deg, #fef9e7, #fcf4dd);
            border-left: 5px solid #f39c12;
            padding: 25px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
            box-shadow: 0 3px 15px rgba(243, 156, 18, 0.1);
        }
        
        .theorem h4 {
            margin: 0 0 15px 0;
            color: #f39c12;
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .algorithm {
            background: linear-gradient(135deg, #e8f5e8, #d4e5d4);
            border-left: 5px solid #27ae60;
            padding: 25px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
            box-shadow: 0 3px 15px rgba(39, 174, 96, 0.1);
        }
        
        .algorithm h4 {
            margin: 0 0 15px 0;
            color: #27ae60;
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .example {
            background: linear-gradient(135deg, #ebf3fd, #d6e9f8);
            border-left: 5px solid #3498db;
            padding: 25px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
            box-shadow: 0 3px 15px rgba(52, 152, 219, 0.1);
        }
        
        .example h4 {
            margin: 0 0 15px 0;
            color: #3498db;
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .practice-problem {
            background: linear-gradient(135deg, #fdf2e9, #fbeee0);
            border-left: 5px solid #e67e22;
            padding: 25px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
            box-shadow: 0 3px 15px rgba(230, 126, 34, 0.1);
        }
        
        .practice-problem h4 {
            margin: 0 0 15px 0;
            color: #e67e22;
            font-size: 1.3em;
            font-weight: 600;
        }
        
        .difficulty {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: 500;
            margin-left: 10px;
        }
        
        .difficulty.medium {
            background: #f39c12;
            color: white;
        }
        
        .difficulty.hard {
            background: #e74c3c;
            color: white;
        }
        
        .difficulty.very-hard {
            background: #8e44ad;
            color: white;
        }
        
        .solution {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px dashed #bdc3c7;
        }
        
        .solution-header {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .viz-container {
            width: 100%;
            height: 420px;
            margin: 25px 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .interactive-demo {
            width: 100%;
            height: auto;
            min-height: 480px;
            margin: 25px 0;
            background: #f8f9fa;
            border-radius: 10px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.1);
            padding: 20px;
            position: relative;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .controls label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #e74c3c;
        }
        
        .controls input, .controls select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .step-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .step-table th, .step-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        
        .step-table th {
            background: #e74c3c;
            color: white;
            font-weight: 500;
        }
        
        .step-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 40px;
            padding: 20px 0;
        }
        
        .btn {
            display: inline-flex;
            align-items: center;
            padding: 12px 25px;
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 3px 15px rgba(231, 76, 60, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(231, 76, 60, 0.4);
        }
        
        .btn.prev::before {
            content: '←';
            margin-right: 8px;
            font-size: 1.1em;
        }

        .btn.next::after {
            content: '→';
            margin-left: 8px;
            font-size: 1.1em;
        }
        
        footer {
            text-align: center;
            color: white;
            padding: 30px 0;
            opacity: 0.9;
            margin-top: 50px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        footer p {
            text-align: center;
            margin: 0;
        }
        
        .math-expression {
            text-align: center;
            margin: 15px 0;
            font-size: 1.1em;
        }
        
        ul, ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .highlight {
            background: linear-gradient(135deg, #fff3cd, #fce4a0);
            padding: 15px;
            border-left: 4px solid #ffc107;
            border-radius: 0 8px 8px 0;
            margin: 15px 0;
        }
        
        .bisection-visualization {
            width: 100%;
            height: 400px;
            margin: 15px 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
        }
        
        /* 代码美化样式 */
        .code-container {
            margin: 20px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            background: #1e1e1e;
        }
        
        .code-header {
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #4a5568;
        }
        
        .code-title {
            color: #ffd700;
            font-weight: 600;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .code-subtitle {
            color: #a0aec0;
            font-size: 0.85em;
            font-style: italic;
        }
        
        .code-content {
            background: #1e1e1e;
            padding: 25px;
            overflow-x: auto;
        }
        
        .code-content pre {
            margin: 0;
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', 'Monaco', 'SF Mono', 'Cascadia Code', 'Roboto Mono', 'Courier New', monospace;
            font-size: 1.05em;
            line-height: 1.8;
            color: #e2e8f0;
            font-weight: 400;
            letter-spacing: 0.3px;
        }
        
        .code-content code {
            background: none;
            padding: 0;
            border: none;
            border-radius: 0;
        }
        
        /* Python 语法高亮 */
        .keyword {
            color: #569cd6;
            font-weight: 600;
        }
        
        .function {
            color: #dcdcaa;
            font-weight: 500;
        }
        
        .parameter {
            color: #9cdcfe;
            font-weight: 400;
        }
        
        .number {
            color: #b5cea8;
            font-weight: 500;
        }
        
        .string {
            color: #ce9178;
            font-weight: 400;
        }
        
        .comment {
            color: #6a9955;
            font-style: italic;
            font-weight: 400;
        }
        
        .builtin {
            color: #4ec9b0;
            font-weight: 500;
        }

        /* AI提示方块样式 */
        .ai-warning {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            border: 2px solid #e0e0e0;
        }
        
        .ai-warning:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            border-color: #ff4444;
        }
        
        .ai-warning::before {
            content: '!';
            color: #e74c3c;
            font-size: 20px;
            font-weight: bold;
            font-family: Arial, sans-serif;
        }
        
        .ai-warning-tooltip {
            position: absolute;
            top: 50px;
            left: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 16px 20px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 1001;
            width: 250px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .ai-warning-tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 20px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(0, 0, 0, 0.9);
        }
        
        .ai-warning:hover .ai-warning-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        /* 代码容器的响应式设计 */
        @media (max-width: 768px) {
            .code-content {
                padding: 15px;
            }
            
            .code-content pre {
                font-size: 0.95em;
                line-height: 1.7;
                letter-spacing: 0.2px;
            }
            
            .code-header {
                padding: 10px 15px;
            }
        }
        
        @media (min-width: 1200px) {
            .code-content pre {
                font-size: 1.1em;
                line-height: 1.9;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .section-content {
                padding: 20px;
            }
            
            .definition, .theorem, .example, .practice-problem {
                padding: 20px;
            }
            
            .nav-buttons {
                flex-direction: column;
                gap: 15px;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }

            .ai-warning {
                width: 35px;
                height: 35px;
                top: 15px;
                left: 15px;
            }
            
            .ai-warning::before {
                font-size: 18px;
            }
            
            .ai-warning-tooltip {
                width: 280px;
                font-size: 13px;
                padding: 14px 18px;
            }
        }
    </style>
</head>
<body>
    <!-- AI内容提示 -->
    <div class="ai-warning">
        <div class="ai-warning-tooltip">
            页面内容由AI生成，请谨慎对待。<br>如发现错误，欢迎反馈。
        </div>
    </div>
    
    <div class="container">
        <a href="../index.html" class="back-link">返回章节概览</a>
        
        <header>
            <h1>3.8 方程的近似解</h1>
            <div class="subtitle">Approximate Solutions of Equations</div>
        </header>
        
        <!-- 3.8.1 二分法 -->
        <div class="content-section">
            <div class="section-header">
                <h2>3.8.1 二分法（二分法求根）</h2>
            </div>
            <div class="section-content">
                <div class="definition">
                    <h4>二分法的基本思想</h4>
                    <p>二分法是一种求方程 $f(x) = 0$ 近似解的数值方法，基于<strong>零点定理</strong>（中间值定理）：</p>
                    <p>如果函数 $f(x)$ 在闭区间 $[a, b]$ 上连续，且 $f(a) \cdot f(b) < 0$，那么在开区间 $(a, b)$ 内至少存在一个零点 $\xi$，使得 $f(\xi) = 0$。</p>
                    
                    <div class="highlight">
                        <p><strong>核心思想：</strong>不断将包含零点的区间对半缩小，逐步逼近零点的位置。</p>
                    </div>
                </div>
                
                <div class="viz-container">
                    <div id="bisection-demo"></div>
                </div>
                
                <div class="algorithm">
                    <h4>二分法算法步骤</h4>
                    <p><strong>输入：</strong>连续函数 $f(x)$，初始区间 $[a_0, b_0]$（满足 $f(a_0) \cdot f(b_0) < 0$），精度 $\varepsilon$</p>
                    
                    <ol>
                        <li><strong>初始化：</strong>设 $a = a_0$，$b = b_0$，$n = 0$</li>
                        <li><strong>计算中点：</strong>$c = \frac{a + b}{2}$</li>
                        <li><strong>判断精度：</strong>如果 $|b - a| < \varepsilon$ 或 $|f(c)| < \varepsilon$，则 $c$ 为近似解，算法结束</li>
                        <li><strong>确定新区间：</strong>
                            <ul>
                                <li>如果 $f(a) \cdot f(c) < 0$，则零点在 $[a, c]$ 内，令 $b = c$</li>
                                <li>如果 $f(c) \cdot f(b) < 0$，则零点在 $[c, b]$ 内，令 $a = c$</li>
                                <li>如果 $f(c) = 0$，则 $c$ 就是精确解</li>
                            </ul>
                        </li>
                        <li><strong>迭代：</strong>$n = n + 1$，返回步骤2</li>
                    </ol>
                    
                    <div class="math-expression">
                        <strong>收敛速度：</strong>经过 $n$ 次迭代后，误差不超过 $\frac{b_0 - a_0}{2^n}$
                    </div>
                </div>
                
                <div class="example">
                    <h4>例1：用二分法求方程 $x^3 - x - 1 = 0$ 在 $[1, 2]$ 内的根</h4>
                    <p>精度要求：$\varepsilon = 0.01$</p>
                    
                    <div class="solution">
                        <div class="solution-header">解：</div>
                        <p><strong>步骤1：验证初始条件</strong></p>
                        <p>$f(x) = x^3 - x - 1$，$f(1) = 1 - 1 - 1 = -1 < 0$</p>
                        <p>$f(2) = 8 - 2 - 1 = 5 > 0$</p>
                        <p>由于 $f(1) \cdot f(2) = -5 < 0$，满足二分法条件。</p>
                        
                        <p><strong>步骤2：迭代计算</strong></p>
                        <table class="step-table">
                            <thead>
                                <tr>
                                    <th>迭代次数 $n$</th>
                                    <th>$a_n$</th>
                                    <th>$b_n$</th>
                                    <th>$c_n = \frac{a_n + b_n}{2}$</th>
                                    <th>$f(c_n)$</th>
                                    <th>符号判断</th>
                                    <th>新区间</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>$0$</td>
                                    <td>$1$</td>
                                    <td>$2$</td>
                                    <td>$1.5$</td>
                                    <td>$0.875$</td>
                                    <td>$f(1) \cdot f(1.5) < 0$</td>
                                    <td>$[1, 1.5]$</td>
                                </tr>
                                <tr>
                                    <td>$1$</td>
                                    <td>$1$</td>
                                    <td>$1.5$</td>
                                    <td>$1.25$</td>
                                    <td>$-0.297$</td>
                                    <td>$f(1.25) \cdot f(1.5) < 0$</td>
                                    <td>$[1.25, 1.5]$</td>
                                </tr>
                                <tr>
                                    <td>$2$</td>
                                    <td>$1.25$</td>
                                    <td>$1.5$</td>
                                    <td>$1.375$</td>
                                    <td>$0.255$</td>
                                    <td>$f(1.25) \cdot f(1.375) < 0$</td>
                                    <td>$[1.25, 1.375]$</td>
                                </tr>
                                <tr>
                                    <td>$3$</td>
                                    <td>$1.25$</td>
                                    <td>$1.375$</td>
                                    <td>$1.3125$</td>
                                    <td>$-0.032$</td>
                                    <td>$f(1.3125) \cdot f(1.375) < 0$</td>
                                    <td>$[1.3125, 1.375]$</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <p>此时区间长度为 $1.375 - 1.3125 = 0.0625 > 0.01$，继续迭代...</p>
                        
                        <p><strong>最终结果：</strong>经过 $7$ 次迭代后，得到近似解 $x \approx 1.3247$</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 3.8.2 切线法（牛顿法） -->
        <div class="content-section">
            <div class="section-header">
                <h2>3.8.2 切线法（牛顿法）</h2>
            </div>
            <div class="section-content">
                <div class="definition">
                    <h4>牛顿法的几何意义</h4>
                    <p>牛顿法（Newton's Method）又称切线法，是一种快速求解方程 $f(x) = 0$ 的数值方法。</p>
                    
                    <p><strong>基本思想：</strong>从初始点 $x_0$ 开始，用函数 $f(x)$ 在该点的切线与 $x$ 轴的交点作为下一次近似，如此迭代直至收敛。</p>
                    
                    <div class="highlight">
                        <p><strong>几何解释：</strong>每次迭代都是用切线来"逼近"函数曲线，利用切线与 $x$ 轴的交点来改进根的估计值。</p>
                    </div>
                </div>
                
                <div class="theorem">
                    <h4>牛顿法迭代公式</h4>
                    <p>设函数 $f(x)$ 在根 $\xi$ 的邻域内具有一阶和二阶连续导数，且 $f'(\xi) \neq 0$。</p>
                    
                    <div class="math-expression">
                        <strong>牛顿法迭代公式：</strong>
                        $$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}, \quad n = 0, 1, 2, \ldots$$
                    </div>
                    
                    <p><strong>推导过程：</strong></p>
                    <p>在点 $(x_n, f(x_n))$ 处，切线方程为：</p>
                    $$y - f(x_n) = f'(x_n)(x - x_n)$$
                    <p>令 $y = 0$，求切线与 $x$ 轴的交点：</p>
                    $$0 - f(x_n) = f'(x_n)(x_{n+1} - x_n)$$
                    <p>解得：</p>
                    $$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$$
                </div>
                
                <div class="viz-container">
                    <div id="newton-demo"></div>
                </div>
                
                <div class="algorithm">
                    <h4>牛顿法算法步骤</h4>
                    <p><strong>输入：</strong>函数 $f(x)$ 及其导数 $f'(x)$，初值 $x_0$，精度 $\varepsilon$</p>
                    
                    <ol>
                        <li><strong>初始化：</strong>设 $n = 0$，选择合适的初始近似值 $x_0$</li>
                        <li><strong>计算函数值：</strong>计算 $f(x_n)$ 和 $f'(x_n)$</li>
                        <li><strong>检查导数：</strong>如果 $|f'(x_n)| < \varepsilon$，算法失败（导数接近零）</li>
                        <li><strong>迭代更新：</strong>$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$</li>
                        <li><strong>收敛检验：</strong>
                            <ul>
                                <li>如果 $|x_{n+1} - x_n| < \varepsilon$ 或 $|f(x_{n+1})| < \varepsilon$，则收敛</li>
                                <li>否则，$n = n + 1$，返回步骤2</li>
                            </ul>
                        </li>
                    </ol>
                    
                    <div class="highlight">
                        <p><strong>收敛阶：</strong>牛顿法是二阶收敛的，即 $\lim\limits_{n \to \infty} \frac{|x_{n+1} - \xi|}{|x_n - \xi|^2} = \frac{|f''(\xi)|}{2|f'(\xi)|}$</p>
                    </div>
                </div>
                
                <div class="example">
                    <h4>例2：用牛顿法求 $\sqrt{2}$ 的近似值</h4>
                    <p>即求解方程 $x^2 - 2 = 0$，取初值 $x_0 = 1.5$</p>
                    
                    <div class="solution">
                        <div class="solution-header">解：</div>
                        <p>$f(x) = x^2 - 2$，$f'(x) = 2x$</p>
                        <p>牛顿法迭代公式：</p>
                        $$x_{n+1} = x_n - \frac{x_n^2 - 2}{2x_n} = \frac{1}{2}\left(x_n + \frac{2}{x_n}\right)$$
                        
                        <table class="step-table">
                            <thead>
                                <tr>
                                    <th>$n$</th>
                                    <th>$x_n$</th>
                                    <th>$f(x_n)$</th>
                                    <th>$f'(x_n)$</th>
                                    <th>$x_{n+1}$</th>
                                    <th>误差 $|x_{n+1} - x_n|$</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>$0$</td>
                                    <td>$1.5$</td>
                                    <td>$0.25$</td>
                                    <td>$3$</td>
                                    <td>$1.41667$</td>
                                    <td>$0.08333$</td>
                                </tr>
                                <tr>
                                    <td>$1$</td>
                                    <td>$1.41667$</td>
                                    <td>$0.00694$</td>
                                    <td>$2.83333$</td>
                                    <td>$1.41422$</td>
                                    <td>$0.00245$</td>
                                </tr>
                                <tr>
                                    <td>$2$</td>
                                    <td>$1.41422$</td>
                                    <td>$0.000006$</td>
                                    <td>$2.82843$</td>
                                    <td>$1.41421$</td>
                                    <td>$0.000003$</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <p><strong>结果：</strong>仅用 $3$ 次迭代就得到了 $\sqrt{2} \approx 1.41421$，精确到小数点后 $5$ 位！</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 3.8.3 割线法 -->
        <div class="content-section">
            <div class="section-header">
                <h2>3.8.3 割线法</h2>
            </div>
            <div class="section-content">
                <div class="definition">
                    <h4>割线法的基本思想</h4>
                    <p>割线法（Secant Method）是牛顿法的一种改进，用于解决无法计算或难以计算导数的情况。</p>
                    
                    <p><strong>核心思想：</strong>用函数在两点间的割线斜率来近似该点处的导数，从而避免显式计算 $f'(x)$。</p>
                    
                    <div class="highlight">
                        <p><strong>几何解释：</strong>每次迭代都通过前两个点的割线与 $x$ 轴的交点来获得新的近似值，类似于牛顿法的切线思想。</p>
                    </div>
                </div>
                
                <div class="theorem">
                    <h4>割线法迭代公式</h4>
                    <p>设 $f(x)$ 在根的邻域内连续，需要两个初始值 $x_0$ 和 $x_1$。</p>
                    
                    <div class="math-expression">
                        <strong>割线法迭代公式：</strong>
                        $$x_{n+1} = x_n - f(x_n) \cdot \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}, \quad n = 1, 2, 3, \ldots$$
                    </div>
                    
                    <p><strong>推导过程：</strong></p>
                    <p>通过点 $(x_{n-1}, f(x_{n-1}))$ 和 $(x_n, f(x_n))$ 的割线方程为：</p>
                    $$y - f(x_n) = \frac{f(x_n) - f(x_{n-1})}{x_n - x_{n-1}}(x - x_n)$$
                    <p>令 $y = 0$，求割线与 $x$ 轴的交点：</p>
                    $$0 - f(x_n) = \frac{f(x_n) - f(x_{n-1})}{x_n - x_{n-1}}(x_{n+1} - x_n)$$
                    <p>解得：</p>
                    $$x_{n+1} = x_n - f(x_n) \cdot \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}$$
                    
                    <div class="highlight">
                        <p><strong>与牛顿法的关系：</strong>割线法可以看作用差商 $\frac{f(x_n) - f(x_{n-1})}{x_n - x_{n-1}}$ 近似导数 $f'(x_n)$</p>
                    </div>
                </div>
                
                <div class="viz-container">
                    <div id="secant-demo"></div>
                </div>
                
                <div class="algorithm">
                    <h4>割线法算法步骤</h4>
                    <p><strong>输入：</strong>函数 $f(x)$，两个初值 $x_0, x_1$，精度 $\varepsilon$，最大迭代次数</p>
                    
                    <ol>
                        <li><strong>初始化：</strong>计算 $f(x_0)$ 和 $f(x_1)$，设 $n = 1$</li>
                        <li><strong>检查分母：</strong>如果 $|f(x_n) - f(x_{n-1})| < \varepsilon$，算法可能失败</li>
                        <li><strong>计算新点：</strong>
                            $$x_{n+1} = x_n - f(x_n) \cdot \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}$$
                        </li>
                        <li><strong>收敛检验：</strong>
                            <ul>
                                <li>如果 $|x_{n+1} - x_n| < \varepsilon$ 或 $|f(x_{n+1})| < \varepsilon$，则收敛</li>
                                <li>否则，$n = n + 1$，返回步骤2</li>
                            </ul>
                        </li>
                    </ol>
                    
                    <div class="math-expression">
                        <strong>收敛阶：</strong>割线法的收敛阶为 $\phi = \frac{1+\sqrt{5}}{2} \approx 1.618$（黄金比例）
                    </div>
                </div>
                
                <div class="example">
                    <h4>例3：用割线法求解 $x^3 - x - 1 = 0$</h4>
                    <p>选择初值 $x_0 = 1$，$x_1 = 2$</p>
                    
                    <div class="solution">
                        <div class="solution-header">解：</div>
                        <p>$f(x) = x^3 - x - 1$</p>
                        <p>$f(1) = -1$，$f(2) = 5$</p>
                        
                        <table class="step-table">
                            <thead>
                                <tr>
                                    <th>$n$</th>
                                    <th>$x_{n-1}$</th>
                                    <th>$x_n$</th>
                                    <th>$f(x_{n-1})$</th>
                                    <th>$f(x_n)$</th>
                                    <th>$x_{n+1}$</th>
                                    <th>误差</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>$1$</td>
                                    <td>$1$</td>
                                    <td>$2$</td>
                                    <td>$-1$</td>
                                    <td>$5$</td>
                                    <td>$1.167$</td>
                                    <td>$0.833$</td>
                                </tr>
                                <tr>
                                    <td>$2$</td>
                                    <td>$2$</td>
                                    <td>$1.167$</td>
                                    <td>$5$</td>
                                    <td>$-0.407$</td>
                                    <td>$1.243$</td>
                                    <td>$0.076$</td>
                                </tr>
                                <tr>
                                    <td>$3$</td>
                                    <td>$1.167$</td>
                                    <td>$1.243$</td>
                                    <td>$-0.407$</td>
                                    <td>$-0.140$</td>
                                    <td>$1.283$</td>
                                    <td>$0.040$</td>
                                </tr>
                                <tr>
                                    <td>$4$</td>
                                    <td>$1.243$</td>
                                    <td>$1.283$</td>
                                    <td>$-0.140$</td>
                                    <td>$-0.036$</td>
                                    <td>$1.297$</td>
                                    <td>$0.014$</td>
                                </tr>
                                <tr>
                                    <td>$5$</td>
                                    <td>$1.283$</td>
                                    <td>$1.297$</td>
                                    <td>$-0.036$</td>
                                    <td>$-0.006$</td>
                                    <td>$1.302$</td>
                                    <td>$0.005$</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <p><strong>收敛结果：</strong>经过 $5$ 次迭代得到 $x \approx 1.302$</p>
                    </div>
                </div>
                
                <div class="example">
                    <h4>例4：三种方法的收敛速度比较</h4>
                    <p>比较二分法、牛顿法、割线法求解同一方程的效率</p>
                    
                    <div class="solution">
                        <div class="solution-header">分析：</div>
                        <p>对方程 $x^3 - x - 1 = 0$ 在 $[1, 2]$ 上求解，精度要求 $10^{-6}$：</p>
                        
                        <table class="step-table">
                            <thead>
                                <tr>
                                    <th>方法</th>
                                    <th>收敛阶</th>
                                    <th>迭代次数</th>
                                    <th>函数计算次数</th>
                                    <th>是否需要导数</th>
                                    <th>初值要求</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>二分法</strong></td>
                                    <td>线性（1）</td>
                                    <td>~20</td>
                                    <td>~20</td>
                                    <td>否</td>
                                    <td>区间 $[a,b]$</td>
                                </tr>
                                <tr>
                                    <td><strong>牛顿法</strong></td>
                                    <td>二次（2）</td>
                                    <td>~5</td>
                                    <td>~10</td>
                                    <td>是</td>
                                    <td>单点，需接近根</td>
                                </tr>
                                <tr>
                                    <td><strong>割线法</strong></td>
                                    <td>超线性（1.618）</td>
                                    <td>~7</td>
                                    <td>~7</td>
                                    <td>否</td>
                                    <td>两点</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <div class="highlight">
                            <p><strong>选择策略：</strong></p>
                            <ul>
                                <li><strong>可靠性优先：</strong>二分法（总是收敛）</li>
                                <li><strong>速度优先且易求导：</strong>牛顿法</li>
                                <li><strong>平衡效率与简便性：</strong>割线法</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 练习题部分 -->
        <div class="content-section">
            <div class="section-header">
                <h2>三种方法对比可视化</h2>
            </div>
            <div class="section-content">
                <div class="example">
                    <h4>求解同一方程的三种方法对比</h4>
                    <p>以方程 $x^3 - x - 1 = 0$ 为例，对比三种方法的收敛过程：</p>
                    
                    <div class="viz-container">
                        <div id="comparison-demo"></div>
                    </div>
                    
                    <div class="highlight">
                        <p><strong>观察要点：</strong></p>
                        <ul>
                            <li><strong>二分法（绿色）：</strong>稳定但缓慢，每次将误差减半</li>
                            <li><strong>牛顿法（蓝色）：</strong>快速收敛，但需要导数信息</li>
                            <li><strong>割线法（紫色）：</strong>介于两者之间，无需导数但收敛较快</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 练习题部分 -->
        <div class="content-section">
            <div class="section-header">
                <h2>练习题</h2>
            </div>
            <div class="section-content">
                <div class="practice-problem">
                    <h4>习题1 <span class="difficulty hard">较难</span></h4>
                    <p>设函数 $f(x) = x^3 + px + q$，其中 $p, q$ 为常数。讨论在什么条件下可以使用二分法求其零点，并分析当 $p = -3, q = 1$ 时的具体情况。</p>
                    
                    <div class="solution">
                        <div class="solution-header">解：</div>
                        <p><strong>步骤1：一般性分析</strong></p>
                        <p>$f'(x) = 3x^2 + p$</p>
                        
                        <p><strong>情况1：</strong>$p \geq 0$ 时，$f'(x) \geq 0$，函数严格单调递增</p>
                        <p>此时 $f(x)$ 最多有一个零点，且：</p>
                        <ul>
                            <li>当 $q > 0$ 时，$f(x) > 0$ 对所有 $x$ 成立，无零点</li>
                            <li>当 $q = 0$ 时，$x = 0$ 是唯一零点</li>
                            <li>当 $q < 0$ 时，存在唯一零点，可用二分法</li>
                        </ul>
                        
                        <p><strong>情况2：</strong>$p < 0$ 时，$f'(x) = 0$ 有解 $x = \pm\sqrt{-\frac{p}{3}}$</p>
                        <p>设 $x_1 = -\sqrt{-\frac{p}{3}}, x_2 = \sqrt{-\frac{p}{3}}$，则：</p>
                        <ul>
                            <li>$f(x)$ 在 $(-\infty, x_1)$ 上递增</li>
                            <li>$f(x)$ 在 $(x_1, x_2)$ 上递减</li>
                            <li>$f(x)$ 在 $(x_2, +\infty)$ 上递增</li>
                        </ul>
                        
                        <p><strong>步骤2：特殊情况 $p = -3, q = 1$</strong></p>
                        <p>$f(x) = x^3 - 3x + 1$，$f'(x) = 3x^2 - 3 = 3(x^2 - 1)$</p>
                        <p>极值点：$x_1 = -1, x_2 = 1$</p>
                        <p>$f(-1) = -1 + 3 + 1 = 3 > 0$（极大值）</p>
                        <p>$f(1) = 1 - 3 + 1 = -1 < 0$（极小值）</p>
                        
                        <p>由于 $f(-1) > 0, f(1) < 0$，且 $\lim\limits_{x \to -\infty} f(x) = -\infty, \lim\limits_{x \to +\infty} f(x) = +\infty$</p>
                        
                        <p><strong>零点分布：</strong></p>
                        <ul>
                            <li>在 $(-\infty, -1)$ 内有一个零点</li>
                            <li>在 $(-1, 1)$ 内有一个零点</li>
                            <li>在 $(1, +\infty)$ 内有一个零点</li>
                        </ul>
                        
                        <p><strong>二分法应用区间：</strong></p>
                        <ul>
                            <li>$[-2, -1]$：$f(-2) = -1 < 0, f(-1) = 3 > 0$</li>
                            <li>$[0, 1]$：$f(0) = 1 > 0, f(1) = -1 < 0$</li>
                            <li>$[1, 2]$：$f(1) = -1 < 0, f(2) = 3 > 0$</li>
                        </ul>
                    </div>
                </div>
                
                <div class="practice-problem">
                    <h4>习题2 <span class="difficulty medium">中等难度</span></h4>
                    <p>用牛顿法求解方程 $e^x - x^2 = 0$ 在 $x_0 = 1$ 附近的根，要求精度达到 $10^{-6}$</p>
                    
                    <div class="solution">
                        <div class="solution-header">解：</div>
                        <p>设 $f(x) = e^x - x^2$，则 $f'(x) = e^x - 2x$</p>
                        
                        <p><strong>牛顿法迭代公式：</strong></p>
                        $$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)} = x_n - \frac{e^{x_n} - x_n^2}{e^{x_n} - 2x_n}$$
                        
                        <p><strong>初值验证：</strong></p>
                        <p>$f(1) = e - 1 \approx 1.718 > 0$</p>
                        <p>$f'(1) = e - 2 \approx 0.718 > 0$</p>
                        
                        <p><strong>迭代计算：</strong></p>
                        <table class="step-table">
                            <thead>
                                <tr>
                                    <th>$n$</th>
                                    <th>$x_n$</th>
                                    <th>$f(x_n)$</th>
                                    <th>$f'(x_n)$</th>
                                    <th>$x_{n+1}$</th>
                                    <th>$|x_{n+1} - x_n|$</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>$0$</td>
                                    <td>$1.000000$</td>
                                    <td>$1.718$</td>
                                    <td>$0.718$</td>
                                    <td>$-1.394$</td>
                                    <td>$2.394$</td>
                                </tr>
                                <tr>
                                    <td>$1$</td>
                                    <td>$-1.394$</td>
                                    <td>$-1.696$</td>
                                    <td>$3.036$</td>
                                    <td>$-0.835$</td>
                                    <td>$0.559$</td>
                                </tr>
                                <tr>
                                    <td>$2$</td>
                                    <td>$-0.835$</td>
                                    <td>$-0.266$</td>
                                    <td>$2.104$</td>
                                    <td>$-0.709$</td>
                                    <td>$0.126$</td>
                                </tr>
                                <tr>
                                    <td>$3$</td>
                                    <td>$-0.709$</td>
                                    <td>$-0.010$</td>
                                    <td>$1.908$</td>
                                    <td>$-0.703$</td>
                                    <td>$0.006$</td>
                                </tr>
                                <tr>
                                    <td>$4$</td>
                                    <td>$-0.703$</td>
                                    <td>$-0.00001$</td>
                                    <td>$1.901$</td>
                                    <td>$-0.7034$</td>
                                    <td>$<10^{-6}$</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <p><strong>结果：</strong>经过4次迭代，得到根的近似值 $x \approx -0.7034$，满足精度要求。</p>
                        
                        <p><strong>验证：</strong></p>
                        <p>$f(-0.7034) = e^{-0.7034} - (-0.7034)^2 \approx 0.495 - 0.495 \approx 0$</p>
                    </div>
                </div>
                
                <div class="practice-problem">
                    <h4>习题3 <span class="difficulty very-hard">高难度</span></h4>
                    <p>设计一个自适应的混合算法，结合二分法、牛顿法和割线法的优点，分析其收敛性和稳定性。</p>
                    
                    <div class="solution">
                        <div class="solution-header">设计方案：</div>
                        
                        <div class="algorithm">
                            <h4>自适应混合求根法</h4>
                            
                            <p><strong>Phase 1：全局搜索阶段（二分法）</strong></p>
                            <ul>
                                <li>使用二分法缩小根的搜索区间到较小范围</li>
                                <li>当区间长度 $|b - a| < 0.1$ 时，转入Phase 2</li>
                                <li>优点：保证收敛，提供可靠的初值</li>
                            </ul>
                            
                            <p><strong>Phase 2：快速收敛阶段（牛顿法/割线法）</strong></p>
                            <ul>
                                <li>如果导数容易计算且数值稳定，使用牛顿法</li>
                                <li>否则使用割线法</li>
                                <li>监控收敛情况：
                                    <ul>
                                        <li>如果连续3步误差不减小，回到Phase 1</li>
                                        <li>如果导数值过小（$|f'(x)| < 10^{-6}$），切换到割线法</li>
                                    </ul>
                                </li>
                            </ul>
                            
                            <p><strong>Phase 3：精化阶段</strong></p>
                            <ul>
                                <li>当 $|f(x)| < 10^{-8}$ 时，进行最后的精化</li>
                                <li>使用高精度算法或迭代修正</li>
                            </ul>
                        </div>
                        
                        <div class="example">
                            <h4>具体实现</h4>
                            <div class="code-container">
                                <div class="code-header">
                                    <span class="code-title">Python</span>
                                    <span class="code-subtitle">自适应混合求根算法</span>
                                </div>
                                <div class="code-content">
<pre><code><span class="keyword">def</span> <span class="function">adaptive_root_finding</span>(<span class="parameter">f</span>, <span class="parameter">fprime</span>, <span class="parameter">a</span>, <span class="parameter">b</span>, <span class="parameter">tol</span>=<span class="number">1e-12</span>):
    <span class="comment"># Phase 1: 二分法全局搜索</span>
    <span class="keyword">while</span> <span class="builtin">abs</span>(<span class="parameter">b</span> - <span class="parameter">a</span>) > <span class="number">0.1</span>:
        <span class="parameter">c</span> = (<span class="parameter">a</span> + <span class="parameter">b</span>) / <span class="number">2</span>
        <span class="keyword">if</span> <span class="function">f</span>(<span class="parameter">a</span>) * <span class="function">f</span>(<span class="parameter">c</span>) < <span class="number">0</span>:
            <span class="parameter">b</span> = <span class="parameter">c</span>
        <span class="keyword">else</span>:
            <span class="parameter">a</span> = <span class="parameter">c</span>
    
    <span class="parameter">x</span> = (<span class="parameter">a</span> + <span class="parameter">b</span>) / <span class="number">2</span>  <span class="comment"># 初值</span>
    
    <span class="comment"># Phase 2: 自适应快速方法</span>
    <span class="keyword">for</span> <span class="parameter">i</span> <span class="keyword">in</span> <span class="builtin">range</span>(<span class="number">50</span>):
        <span class="parameter">fx</span> = <span class="function">f</span>(<span class="parameter">x</span>)
        <span class="keyword">if</span> <span class="builtin">abs</span>(<span class="parameter">fx</span>) < <span class="parameter">tol</span>:
            <span class="keyword">return</span> <span class="parameter">x</span>, <span class="parameter">i</span>, <span class="string">"收敛"</span>
        
        <span class="comment"># 尝试牛顿法</span>
        <span class="keyword">if</span> <span class="parameter">fprime</span> <span class="keyword">is not</span> <span class="builtin">None</span>:
            <span class="parameter">fpx</span> = <span class="function">fprime</span>(<span class="parameter">x</span>)
            <span class="keyword">if</span> <span class="builtin">abs</span>(<span class="parameter">fpx</span>) > <span class="number">1e-6</span>:
                <span class="parameter">x_new</span> = <span class="parameter">x</span> - <span class="parameter">fx</span> / <span class="parameter">fpx</span>
                <span class="comment"># 检查是否在合理范围内</span>
                <span class="keyword">if</span> <span class="parameter">a</span> <= <span class="parameter">x_new</span> <= <span class="parameter">b</span>:
                    <span class="parameter">x</span> = <span class="parameter">x_new</span>
                    <span class="keyword">continue</span>
        
        <span class="comment"># 回退到割线法或二分法</span>
        <span class="comment"># ... 具体实现</span>
    
    <span class="keyword">return</span> <span class="parameter">x</span>, -<span class="number">1</span>, <span class="string">"未收敛"</span></code></pre>
                                </div>
                            </div>
                        </div>
                        
                        <div class="theorem">
                            <h4>收敛性分析</h4>
                            <ul>
                                <li><strong>全局收敛性：</strong>由二分法保证</li>
                                <li><strong>局部快速收敛：</strong>由牛顿法或割线法实现</li>
                                <li><strong>数值稳定性：</strong>通过自适应切换避免数值问题</li>
                            </ul>
                        </div>
                        
                        <div class="highlight">
                            <h4>性能优势</h4>
                            <ul>
                                <li>结合了各方法的优点</li>
                                <li>对初值不敏感</li>
                                <li>处理特殊情况（重根、导数为零等）</li>
                                <li>计算复杂度合理</li>
                            </ul>
                        </div>
                        
                        <div class="definition">
                            <h4>应用场景</h4>
                            <ul>
                                <li>工程计算中的通用求根器</li>
                                <li>科学计算软件的底层算法</li>
                                <li>需要高可靠性的数值计算</li>
                            </ul>
                            
                            <p><strong>实际建议：</strong>现代数值软件如MATLAB的fzero、Python的scipy.optimize.brentq等都采用类似的混合策略。</p>
                        </div>
                        
                        <table class="step-table">
                            <thead>
                                <tr>
                                    <th>算法阶段</th>
                                    <th>使用方法</th>
                                    <th>触发条件</th>
                                    <th>优点</th>
                                    <th>风险控制</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>Phase 1</strong></td>
                                    <td>二分法</td>
                                    <td>初始化</td>
                                    <td>绝对收敛</td>
                                    <td>区间包围保证</td>
                                </tr>
                                <tr>
                                    <td><strong>Phase 2a</strong></td>
                                    <td>牛顿法</td>
                                    <td>$|f'(x)| > 10^{-6}$</td>
                                    <td>二次收敛</td>
                                    <td>边界检查</td>
                                </tr>
                                <tr>
                                    <td><strong>Phase 2b</strong></td>
                                    <td>割线法</td>
                                    <td>牛顿法失效</td>
                                    <td>无需导数</td>
                                    <td>发散检测</td>
                                </tr>
                                <tr>
                                    <td><strong>Phase 3</strong></td>
                                    <td>精化算法</td>
                                    <td>$|f(x)| < 10^{-8}$</td>
                                    <td>高精度</td>
                                    <td>迭代限制</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="nav-buttons">
            <a href="3.7.html" class="btn prev">上一节：3.7 曲率</a>
            <a href="../index.html" class="btn next">返回章节概览</a>
        </div>
        
        <footer>
            <p>&copy; 2025 高等数学复习系统 - 方程的近似解</p>
        </footer>
    </div>

    <script>
        // 等待 MathJax 加载完成
        window.addEventListener('load', function() {
            // 创建二分法可视化
            createBisectionDemo();
            // 创建牛顿法可视化
            createNewtonDemo();
            // 创建割线法可视化
            createSecantDemo();
            // 创建对比可视化
            createComparisonDemo();
        });

        // 二分法可视化
        function createBisectionDemo() {
            const container = document.getElementById('bisection-demo');
            if (!container) return;

            // 函数定义：f(x) = x^3 - x - 1
            const f = x => x * x * x - x - 1;
            
            // 生成函数曲线数据
            const xRange = [];
            const yRange = [];
            for (let x = 0.5; x <= 2.5; x += 0.01) {
                xRange.push(x);
                yRange.push(f(x));
            }

            // 二分法迭代步骤
            let a = 1, b = 2;
            const iterations = [];
            for (let i = 0; i < 5; i++) {
                const c = (a + b) / 2;
                const fc = f(c);
                iterations.push({
                    step: i + 1,
                    a: a,
                    b: b,
                    c: c,
                    fc: fc
                });
                
                if (f(a) * fc < 0) {
                    b = c;
                } else {
                    a = c;
                }
            }

            // 创建图表数据
            const traces = [
                {
                    x: xRange,
                    y: yRange,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'f(x) = x³ - x - 1',
                    line: { color: '#e74c3c', width: 3 }
                },
                {
                    x: [0.5, 2.5],
                    y: [0, 0],
                    type: 'scatter',
                    mode: 'lines',
                    name: 'x轴',
                    line: { color: '#34495e', width: 1, dash: 'dot' }
                }
            ];

            // 添加迭代区间
            iterations.forEach((iter, index) => {
                if (index < 4) { // 只显示前4步
                    traces.push({
                        x: [iter.a, iter.b],
                        y: [0, 0],
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: `第${iter.step}步: [${iter.a.toFixed(3)}, ${iter.b.toFixed(3)}]`,
                        line: { color: `hsl(${120 + index * 40}, 70%, 50%)`, width: 4 },
                        marker: { size: 8 }
                    });
                    
                    // 添加中点标记
                    traces.push({
                        x: [iter.c],
                        y: [iter.fc],
                        type: 'scatter',
                        mode: 'markers',
                        name: `中点${iter.step}: (${iter.c.toFixed(3)}, ${iter.fc.toFixed(3)})`,
                        marker: { 
                            color: `hsl(${120 + index * 40}, 70%, 50%)`, 
                            size: 10,
                            symbol: 'circle'
                        },
                        showlegend: false
                    });
                }
            });

            const layout = {
                title: {
                    text: '二分法求根演示',
                    font: { size: 16, color: '#2c3e50' }
                },
                xaxis: {
                    title: 'x',
                    range: [0.5, 2.5]
                },
                yaxis: {
                    title: 'f(x)',
                    range: [-2, 3]
                },
                legend: {
                    x: 0.7,
                    y: 0.95
                },
                margin: { l: 60, r: 50, t: 50, b: 50 }
            };

            Plotly.newPlot('bisection-demo', traces, layout, {responsive: true});
        }

        // 牛顿法可视化
        function createNewtonDemo() {
            const container = document.getElementById('newton-demo');
            if (!container) return;

            // 函数定义：f(x) = x^2 - 2 (求根号2)
            const f = x => x * x - 2;
            const df = x => 2 * x; // 导数

            // 生成函数曲线数据
            const xRange = [];
            const yRange = [];
            for (let x = 0.5; x <= 2.5; x += 0.01) {
                xRange.push(x);
                yRange.push(f(x));
            }

            // 牛顿法迭代
            let x = 2.0; // 初值
            const iterations = [];
            for (let i = 0; i < 4; i++) {
                const fx = f(x);
                const dfx = df(x);
                const x_new = x - fx / dfx;
                
                iterations.push({
                    step: i + 1,
                    x: x,
                    fx: fx,
                    dfx: dfx,
                    x_new: x_new
                });
                
                x = x_new;
            }

            // 创建图表数据
            const traces = [
                {
                    x: xRange,
                    y: yRange,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'f(x) = x² - 2',
                    line: { color: '#e74c3c', width: 3 }
                },
                {
                    x: [0.5, 2.5],
                    y: [0, 0],
                    type: 'scatter',
                    mode: 'lines',
                    name: 'x轴',
                    line: { color: '#34495e', width: 1, dash: 'dot' }
                }
            ];

            // 添加切线和迭代过程
            iterations.forEach((iter, index) => {
                if (index < 3) { // 只显示前3步
                    const color = `hsl(${200 + index * 50}, 70%, 50%)`;
                    
                    // 切线
                    const x1 = iter.x - 0.5;
                    const x2 = iter.x + 0.5;
                    const y1 = iter.fx + iter.dfx * (x1 - iter.x);
                    const y2 = iter.fx + iter.dfx * (x2 - iter.x);
                    
                    traces.push({
                        x: [x1, x2],
                        y: [y1, y2],
                        type: 'scatter',
                        mode: 'lines',
                        name: `第${iter.step}步切线`,
                        line: { color: color, width: 2, dash: 'dash' }
                    });
                    
                    // 当前点
                    traces.push({
                        x: [iter.x],
                        y: [iter.fx],
                        type: 'scatter',
                        mode: 'markers',
                        name: `点${iter.step}: (${iter.x.toFixed(3)}, ${iter.fx.toFixed(3)})`,
                        marker: { 
                            color: color, 
                            size: 12,
                            symbol: 'circle'
                        },
                        showlegend: false
                    });
                    
                    // 垂直线到x轴
                    traces.push({
                        x: [iter.x, iter.x],
                        y: [0, iter.fx],
                        type: 'scatter',
                        mode: 'lines',
                        line: { color: color, width: 1, dash: 'dot' },
                        showlegend: false
                    });
                    
                    // 下一个点
                    traces.push({
                        x: [iter.x_new],
                        y: [0],
                        type: 'scatter',
                        mode: 'markers',
                        name: `x${iter.step+1} = ${iter.x_new.toFixed(3)}`,
                        marker: { 
                            color: color, 
                            size: 10,
                            symbol: 'square'
                        },
                        showlegend: false
                    });
                }
            });

            const layout = {
                title: {
                    text: '牛顿法求根演示 (求√2)',
                    font: { size: 16, color: '#2c3e50' }
                },
                xaxis: {
                    title: 'x',
                    range: [0.5, 2.5]
                },
                yaxis: {
                    title: 'f(x)',
                    range: [-1.5, 2.5]
                },
                legend: {
                    x: 0.7,
                    y: 0.95
                },
                margin: { l: 60, r: 50, t: 50, b: 50 }
            };

            Plotly.newPlot('newton-demo', traces, layout, {responsive: true});
        }

        // 割线法可视化
        function createSecantDemo() {
            const container = document.getElementById('secant-demo');
            if (!container) return;

            // 函数定义：f(x) = x^3 - x - 1
            const f = x => x * x * x - x - 1;

            // 生成函数曲线数据
            const xRange = [];
            const yRange = [];
            for (let x = 0.5; x <= 2.5; x += 0.01) {
                xRange.push(x);
                yRange.push(f(x));
            }

            // 割线法迭代
            let x0 = 1.0, x1 = 2.0; // 初值
            const iterations = [];
            for (let i = 0; i < 4; i++) {
                const fx0 = f(x0);
                const fx1 = f(x1);
                const x2 = x1 - fx1 * (x1 - x0) / (fx1 - fx0);
                
                iterations.push({
                    step: i + 1,
                    x0: x0,
                    x1: x1,
                    fx0: fx0,
                    fx1: fx1,
                    x2: x2
                });
                
                x0 = x1;
                x1 = x2;
            }

            // 创建图表数据
            const traces = [
                {
                    x: xRange,
                    y: yRange,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'f(x) = x³ - x - 1',
                    line: { color: '#e74c3c', width: 3 }
                },
                {
                    x: [0.5, 2.5],
                    y: [0, 0],
                    type: 'scatter',
                    mode: 'lines',
                    name: 'x轴',
                    line: { color: '#34495e', width: 1, dash: 'dot' }
                }
            ];

            // 添加割线和迭代过程
            iterations.forEach((iter, index) => {
                if (index < 3) { // 只显示前3步
                    const color = `hsl(${280 + index * 30}, 70%, 50%)`;
                    
                    // 割线
                    const slope = (iter.fx1 - iter.fx0) / (iter.x1 - iter.x0);
                    const x_left = Math.min(iter.x0, iter.x1) - 0.3;
                    const x_right = Math.max(iter.x0, iter.x1) + 0.3;
                    const y_left = iter.fx1 + slope * (x_left - iter.x1);
                    const y_right = iter.fx1 + slope * (x_right - iter.x1);
                    
                    traces.push({
                        x: [x_left, x_right],
                        y: [y_left, y_right],
                        type: 'scatter',
                        mode: 'lines',
                        name: `第${iter.step}步割线`,
                        line: { color: color, width: 2, dash: 'dash' }
                    });
                    
                    // 两个定点
                    traces.push({
                        x: [iter.x0, iter.x1],
                        y: [iter.fx0, iter.fx1],
                        type: 'scatter',
                        mode: 'markers',
                        name: `割线点${iter.step}`,
                        marker: { 
                            color: color, 
                            size: 10,
                            symbol: 'circle'
                        }
                    });
                    
                    // 新的交点
                    traces.push({
                        x: [iter.x2],
                        y: [0],
                        type: 'scatter',
                        mode: 'markers',
                        name: `x${iter.step+2} = ${iter.x2.toFixed(3)}`,
                        marker: { 
                            color: color, 
                            size: 12,
                            symbol: 'star'
                        },
                        showlegend: false
                    });
                }
            });

            const layout = {
                title: {
                    text: '割线法求根演示',
                    font: { size: 16, color: '#2c3e50' }
                },
                xaxis: {
                    title: 'x',
                    range: [0.5, 2.5]
                },
                yaxis: {
                    title: 'f(x)',
                    range: [-2, 3]
                },
                legend: {
                    x: 0.7,
                    y: 0.95
                },
                margin: { l: 60, r: 50, t: 50, b: 50 }
            };

            Plotly.newPlot('secant-demo', traces, layout, {responsive: true});
        }

        // 三种方法对比可视化
        function createComparisonDemo() {
            const container = document.getElementById('comparison-demo');
            if (!container) return;

            // 函数定义：f(x) = x^3 - x - 1
            const f = x => x * x * x - x - 1;
            const df = x => 3 * x * x - 1; // 导数

            // 真实根（用于误差计算）
            const trueRoot = 1.3247179572447;

            // 二分法
            function bisection() {
                let a = 1, b = 2;
                const results = [{x: 1.5, error: Math.abs(1.5 - trueRoot), iter: 0}];
                
                for (let i = 1; i <= 15; i++) {
                    const c = (a + b) / 2;
                    if (f(a) * f(c) < 0) {
                        b = c;
                    } else {
                        a = c;
                    }
                    results.push({
                        x: c,
                        error: Math.abs(c - trueRoot),
                        iter: i
                    });
                }
                return results;
            }

            // 牛顿法
            function newton() {
                let x = 1.5;
                const results = [{x: x, error: Math.abs(x - trueRoot), iter: 0}];
                
                for (let i = 1; i <= 8; i++) {
                    x = x - f(x) / df(x);
                    results.push({
                        x: x,
                        error: Math.abs(x - trueRoot),
                        iter: i
                    });
                    if (results[i].error < 1e-12) break;
                }
                return results;
            }

            // 割线法
            function secant() {
                let x0 = 1, x1 = 2;
                const results = [
                    {x: x0, error: Math.abs(x0 - trueRoot), iter: 0},
                    {x: x1, error: Math.abs(x1 - trueRoot), iter: 1}
                ];
                
                for (let i = 2; i <= 10; i++) {
                    const x2 = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0));
                    results.push({
                        x: x2,
                        error: Math.abs(x2 - trueRoot),
                        iter: i
                    });
                    x0 = x1;
                    x1 = x2;
                    if (results[i].error < 1e-12) break;
                }
                return results;
            }

            const bisectionData = bisection();
            const newtonData = newton();
            const secantData = secant();

            // 创建收敛图
            const traces = [
                {
                    x: bisectionData.map(d => d.iter),
                    y: bisectionData.map(d => Math.log10(d.error)),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: '二分法',
                    line: { color: '#27ae60', width: 3 },
                    marker: { size: 8, symbol: 'circle' }
                },
                {
                    x: newtonData.map(d => d.iter),
                    y: newtonData.map(d => Math.log10(d.error)),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: '牛顿法',
                    line: { color: '#3498db', width: 3 },
                    marker: { size: 8, symbol: 'square' }
                },
                {
                    x: secantData.map(d => d.iter),
                    y: secantData.map(d => Math.log10(d.error)),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: '割线法',
                    line: { color: '#9b59b6', width: 3 },
                    marker: { size: 8, symbol: 'diamond' }
                }
            ];

            const layout = {
                title: {
                    text: '三种方法收敛速度对比 (误差 vs 迭代次数)',
                    font: { size: 16, color: '#2c3e50' }
                },
                xaxis: {
                    title: '迭代次数'
                },
                yaxis: {
                    title: 'log₁₀(|误差|)'
                },
                legend: {
                    x: 0.7,
                    y: 0.95
                },
                annotations: [
                    {
                        x: 8,
                        y: -2,
                        text: '线性收敛',
                        showarrow: true,
                        arrowhead: 2,
                        ax: 0,
                        ay: -30,
                        font: { color: '#27ae60' }
                    },
                    {
                        x: 4,
                        y: -8,
                        text: '二次收敛',
                        showarrow: true,
                        arrowhead: 2,
                        ax: 0,
                        ay: -30,
                        font: { color: '#3498db' }
                    },
                    {
                        x: 6,
                        y: -6,
                        text: '超线性收敛',
                        showarrow: true,
                        arrowhead: 2,
                        ax: 0,
                        ay: -30,
                        font: { color: '#9b59b6' }
                    }
                ],
                margin: { l: 60, r: 50, t: 50, b: 50 }
            };

            Plotly.newPlot('comparison-demo', traces, layout, {responsive: true});
        }
    </script>
</body>
</html>
